// Chunk: docs/chunks/pty_wakeup_reentrant - Unified event queue architecture
//! Editor event types for the unified event queue.
//!
//! All event sources (keyboard, mouse, scroll, PTY wakeup, cursor blink, window resize)
//! send their events through a single channel rather than each holding a clone of
//! `Rc<RefCell<EditorController>>`. This eliminates the reentrant borrow panics that
//! occur when multiple event sources try to borrow the controller simultaneously.
//!
//! The event queue is drained by a single callback that owns the controller directly
//! (no `Rc`, no `RefCell`), ensuring exclusive access during event processing.

use std::path::PathBuf;

use crate::input::{KeyEvent, MarkedTextEvent, MouseEvent, ScrollDelta, TextInputEvent};

/// Unified event type for all editor events.
///
/// All event sources send one of these variants to the event channel. The drain
/// loop processes events one at a time, ensuring the controller is never borrowed
/// by multiple callbacks simultaneously.
#[derive(Debug)]
pub enum EditorEvent {
    /// A keyboard event (key down)
    Key(KeyEvent),

    /// A mouse event (click, drag, release)
    Mouse(MouseEvent),

    /// A scroll event (trackpad or mouse wheel)
    Scroll(ScrollDelta),

    /// PTY data is available - poll all agents/terminals
    ///
    /// This replaces the `dispatch_async` + `PtyWakeup::signal` pattern.
    /// The PTY reader thread sends this when data arrives.
    PtyWakeup,

    /// Cursor blink timer fired - toggle cursor visibility
    CursorBlink,

    /// Window was resized or moved between displays
    ///
    /// This covers both `windowDidResize:` and `windowDidChangeBackingProperties:`.
    Resize,

    /// Files were dropped onto the view
    ///
    /// Contains the list of file paths (as UTF-8 strings) that were dropped.
    /// The paths are absolute and need shell escaping before insertion.
    // Chunk: docs/chunks/dragdrop_file_paste - File drop event for drag-and-drop
    FileDrop(Vec<String>),

    // Chunk: docs/chunks/file_change_events - External file modification detection
    /// A file was modified externally (on disk)
    ///
    /// This event is sent when the filesystem watcher detects that a file
    /// within the workspace was modified by an external process. The path
    /// is absolute.
    FileChanged(PathBuf),

    // Chunk: docs/chunks/deletion_rename_handling - External file deletion detection
    /// A file was deleted externally (from disk)
    ///
    /// This event is sent when the filesystem watcher detects that a file
    /// with an open buffer was removed by an external process. The path
    /// is absolute.
    FileDeleted(PathBuf),

    // Chunk: docs/chunks/deletion_rename_handling - External file rename detection
    /// A file was renamed externally
    ///
    /// This event is sent when the filesystem watcher detects that a file
    /// with an open buffer was renamed by an external process. Both paths
    /// are absolute.
    FileRenamed { from: PathBuf, to: PathBuf },

    // Chunk: docs/chunks/unicode_ime_input - NSTextInputClient for IME support
    /// Text insertion from IME or other text input sources.
    ///
    /// This event is generated by the macOS text input system when text should
    /// be inserted. Unlike `Key` events, this represents final text that should
    /// be inserted verbatim, not physical keystrokes to be interpreted.
    InsertText(TextInputEvent),

    // Chunk: docs/chunks/unicode_ime_input - NSTextInputClient for IME support
    /// IME composition in progress (marked text).
    ///
    /// This event is sent when the user is composing text using an IME.
    /// The marked text should be displayed with an underline to indicate
    /// it is uncommitted. The composition continues until either:
    /// - `InsertText` is sent (committing the composition)
    /// - `UnmarkText` is sent (canceling the composition)
    SetMarkedText(MarkedTextEvent),

    // Chunk: docs/chunks/unicode_ime_input - NSTextInputClient for IME support
    /// IME composition canceled or committed.
    ///
    /// This event clears any marked text without inserting. It's sent when:
    /// - The user presses Escape during composition
    /// - Focus changes away from the text field
    /// - The text input system needs to clear marked state
    UnmarkText,

    // Chunk: docs/chunks/app_nap_activity_assertions - Window resign key event
    /// Window lost key status (app was backgrounded).
    ///
    /// This event is sent from the windowDidResignKey delegate method to notify
    /// the editor that the window is no longer key. Used to release the activity
    /// assertion immediately when backgrounding, rather than waiting for the
    /// 2-second timeout.
    WindowResignKey,

    // Chunk: docs/chunks/app_nap_file_watcher_pause - Pause file watchers for App Nap
    /// Window lost key status - pause file watchers to allow App Nap.
    ///
    /// This event is sent when the window loses key status (`windowDidResignKey:`),
    /// indicating the app is being backgrounded. File watchers should be paused
    /// to eliminate periodic wakeups that prevent App Nap.
    PauseFileWatchers,

    // Chunk: docs/chunks/app_nap_file_watcher_pause - Resume file watchers after App Nap
    /// Window gained key status - resume file watchers.
    ///
    /// This event is sent when the window becomes key (`windowDidBecomeKey:`),
    /// indicating the app is returning to the foreground. File watchers should
    /// be resumed and any files modified while paused should be detected.
    ResumeFileWatchers,
}

impl EditorEvent {
    /// Returns true if this is a user input event (key, mouse, scroll, file drop, text input).
    ///
    /// Used for resetting cursor blink state on user activity.
    // Chunk: docs/chunks/unicode_ime_input - Include text input events as user input
    pub fn is_user_input(&self) -> bool {
        matches!(
            self,
            EditorEvent::Key(_)
                | EditorEvent::Mouse(_)
                | EditorEvent::Scroll(_)
                | EditorEvent::FileDrop(_)
                | EditorEvent::InsertText(_)
                | EditorEvent::SetMarkedText(_)
                | EditorEvent::UnmarkText
        )
    }

    // Chunk: docs/chunks/terminal_flood_starvation - Input-first event partitioning
    // Chunk: docs/chunks/file_change_events - FileChanged is a priority event
    // Chunk: docs/chunks/deletion_rename_handling - FileDeleted and FileRenamed are priority events
    // Chunk: docs/chunks/unicode_ime_input - Text input events are priority events
    /// Returns true if this event should be processed before PTY wakeup events.
    ///
    /// Priority events include all user input events plus Resize (window resize
    /// should be responsive) and file change events (external edits, deletions,
    /// and renames should be processed promptly). CursorBlink is NOT included
    /// since it's cosmetic.
    /// This ensures input latency is bounded by the cost of processing priority
    /// events, not by accumulated terminal output.
    pub fn is_priority_event(&self) -> bool {
        matches!(
            self,
            EditorEvent::Key(_)
                | EditorEvent::Mouse(_)
                | EditorEvent::Scroll(_)
                | EditorEvent::FileDrop(_)
                | EditorEvent::Resize
                | EditorEvent::FileChanged(_)
                | EditorEvent::FileDeleted(_)
                | EditorEvent::FileRenamed { .. }
                | EditorEvent::InsertText(_)
                | EditorEvent::SetMarkedText(_)
                | EditorEvent::UnmarkText
        )
    }

    /// Returns true if this is a key event.
    pub fn is_key(&self) -> bool {
        matches!(self, EditorEvent::Key(_))
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::path::PathBuf;
    use lite_edit_input::{KeyEvent, MouseEvent, MouseEventKind, Modifiers, ScrollDelta};

    // Chunk: docs/chunks/terminal_flood_starvation - Tests for is_priority_event

    #[test]
    fn test_key_is_priority() {
        let event = EditorEvent::Key(KeyEvent::char('a'));
        assert!(event.is_priority_event());
    }

    #[test]
    fn test_mouse_is_priority() {
        let event = EditorEvent::Mouse(MouseEvent {
            kind: MouseEventKind::Down,
            position: (0.0, 0.0),
            modifiers: Modifiers::default(),
            click_count: 1,
        });
        assert!(event.is_priority_event());
    }

    #[test]
    fn test_scroll_is_priority() {
        let event = EditorEvent::Scroll(ScrollDelta {
            dx: 0.0,
            dy: 10.0,
            mouse_position: None,
        });
        assert!(event.is_priority_event());
    }

    #[test]
    fn test_file_drop_is_priority() {
        let event = EditorEvent::FileDrop(vec!["/path/to/file.txt".to_string()]);
        assert!(event.is_priority_event());
    }

    #[test]
    fn test_resize_is_priority() {
        let event = EditorEvent::Resize;
        assert!(event.is_priority_event());
    }

    #[test]
    fn test_pty_wakeup_is_not_priority() {
        let event = EditorEvent::PtyWakeup;
        assert!(!event.is_priority_event());
    }

    #[test]
    fn test_cursor_blink_is_not_priority() {
        let event = EditorEvent::CursorBlink;
        assert!(!event.is_priority_event());
    }

    // Chunk: docs/chunks/file_change_events - Tests for FileChanged event
    #[test]
    fn test_file_changed_is_priority() {
        let event = EditorEvent::FileChanged(PathBuf::from("/path/to/file.rs"));
        assert!(event.is_priority_event());
    }

    #[test]
    fn test_file_changed_is_not_user_input() {
        let event = EditorEvent::FileChanged(PathBuf::from("/path/to/file.rs"));
        assert!(!event.is_user_input());
    }

    // Chunk: docs/chunks/deletion_rename_handling - Tests for FileDeleted event
    #[test]
    fn test_file_deleted_is_priority() {
        let event = EditorEvent::FileDeleted(PathBuf::from("/path/to/file.rs"));
        assert!(event.is_priority_event());
    }

    #[test]
    fn test_file_deleted_is_not_user_input() {
        let event = EditorEvent::FileDeleted(PathBuf::from("/path/to/file.rs"));
        assert!(!event.is_user_input());
    }

    // Chunk: docs/chunks/deletion_rename_handling - Tests for FileRenamed event
    #[test]
    fn test_file_renamed_is_priority() {
        let event = EditorEvent::FileRenamed {
            from: PathBuf::from("/path/to/old.rs"),
            to: PathBuf::from("/path/to/new.rs"),
        };
        assert!(event.is_priority_event());
    }

    #[test]
    fn test_file_renamed_is_not_user_input() {
        let event = EditorEvent::FileRenamed {
            from: PathBuf::from("/path/to/old.rs"),
            to: PathBuf::from("/path/to/new.rs"),
        };
        assert!(!event.is_user_input());
    }

    #[test]
    fn test_priority_events_superset_of_user_input() {
        // All user input events should also be priority events
        let user_input_events = vec![
            EditorEvent::Key(KeyEvent::char('x')),
            EditorEvent::Mouse(MouseEvent {
                kind: MouseEventKind::Moved,
                position: (0.0, 0.0),
                modifiers: Modifiers::default(),
                click_count: 0,
            }),
            EditorEvent::Scroll(ScrollDelta {
                dx: 0.0,
                dy: 0.0,
                mouse_position: None,
            }),
            EditorEvent::FileDrop(vec![]),
        ];

        for event in user_input_events {
            assert!(
                event.is_user_input(),
                "Event {:?} should be user input",
                event
            );
            assert!(
                event.is_priority_event(),
                "User input event {:?} should also be priority",
                event
            );
        }
    }

    // Chunk: docs/chunks/unicode_ime_input - Tests for text input events

    #[test]
    fn test_insert_text_is_user_input() {
        use lite_edit_input::TextInputEvent;
        let event = EditorEvent::InsertText(TextInputEvent::new("hello"));
        assert!(event.is_user_input());
    }

    #[test]
    fn test_insert_text_is_priority() {
        use lite_edit_input::TextInputEvent;
        let event = EditorEvent::InsertText(TextInputEvent::new("hello"));
        assert!(event.is_priority_event());
    }

    #[test]
    fn test_set_marked_text_is_user_input() {
        use lite_edit_input::MarkedTextEvent;
        let event = EditorEvent::SetMarkedText(MarkedTextEvent::new("にほん"));
        assert!(event.is_user_input());
    }

    #[test]
    fn test_set_marked_text_is_priority() {
        use lite_edit_input::MarkedTextEvent;
        let event = EditorEvent::SetMarkedText(MarkedTextEvent::new("にほん"));
        assert!(event.is_priority_event());
    }

    #[test]
    fn test_unmark_text_is_user_input() {
        let event = EditorEvent::UnmarkText;
        assert!(event.is_user_input());
    }

    #[test]
    fn test_unmark_text_is_priority() {
        let event = EditorEvent::UnmarkText;
        assert!(event.is_priority_event());
    }
}
