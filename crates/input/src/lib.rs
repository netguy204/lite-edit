// Chunk: docs/chunks/editable_buffer - Main loop + input events + editable buffer
// Chunk: docs/chunks/terminal_input_encoding - Shared input types crate
// Chunk: docs/chunks/pty_wakeup_reentrant - WakeupSignal trait for cross-crate PTY wakeup
// Chunk: docs/chunks/unicode_ime_input - NSTextInputClient for IME support
//!
//! Input event types for keyboard, mouse, and scroll handling.
//!
//! These types abstract over macOS NSEvent details and provide a clean
//! Rust-native interface for input handling. This crate is shared between
//! the editor and terminal crates to avoid circular dependencies.
//!
//! Additionally, this crate provides the `WakeupSignal` trait for cross-crate
//! PTY wakeup signaling, allowing the terminal crate to signal the editor's
//! event loop without depending on the editor crate directly.
//!
//! ## Text Input Events
//!
//! The crate distinguishes between two types of text input:
//!
//! - **KeyEvent**: Represents a physical key press, used for shortcuts, navigation,
//!   and control keys. These are identified by their virtual key code.
//!
//! - **TextInputEvent / MarkedTextEvent**: Represents text to be inserted, coming
//!   from keyboard, IME composition, paste, or dictation. These are the final text
//!   that should be inserted into the document.
//!
//! This separation enables proper IME (Input Method Editor) support for CJK
//! languages where composition involves multiple keystrokes before committing.

/// A keyboard event.
#[derive(Debug, Clone, PartialEq)]
pub struct KeyEvent {
    /// The key that was pressed
    pub key: Key,
    /// Modifier keys held during the event
    pub modifiers: Modifiers,
}

// Chunk: docs/chunks/unicode_ime_input - NSTextInputClient for IME support
/// Text insertion from keyboard, IME, paste, or dictation.
///
/// Unlike KeyEvent, this represents final text to insert, not physical keys.
/// This event is generated by the macOS text input system after processing
/// keyboard input through any active input method.
///
/// # Examples
///
/// - Direct keyboard input: typing 'a' generates a TextInputEvent with text "a"
/// - IME composition: completing 日本語 input generates a TextInputEvent with text "日本語"
/// - Paste: pasting text generates a TextInputEvent with the pasted content
/// - Dictation: speaking text generates a TextInputEvent with the transcribed text
#[derive(Debug, Clone, PartialEq)]
pub struct TextInputEvent {
    /// The text to insert
    pub text: String,
    /// Optional range to replace (for IME replacement). None = insert at cursor.
    /// The range is in buffer character offsets from the start of the document.
    pub replacement_range: Option<std::ops::Range<usize>>,
}

impl TextInputEvent {
    /// Creates a new text input event for simple text insertion at cursor.
    pub fn new(text: impl Into<String>) -> Self {
        Self {
            text: text.into(),
            replacement_range: None,
        }
    }

    /// Creates a new text input event that replaces a range.
    pub fn with_replacement(text: impl Into<String>, range: std::ops::Range<usize>) -> Self {
        Self {
            text: text.into(),
            replacement_range: Some(range),
        }
    }
}

// Chunk: docs/chunks/unicode_ime_input - NSTextInputClient for IME support
/// IME marked text (in-progress composition).
///
/// Marked text is displayed with an underline to indicate it's uncommitted.
/// The user can continue composing until they commit or cancel.
///
/// # IME Workflow
///
/// 1. User types romanji (e.g., "nihon")
/// 2. System sends MarkedTextEvent with text "にほん" (hiragana)
/// 3. User presses Space to see kanji candidates
/// 4. System updates MarkedTextEvent with selected candidate "日本"
/// 5. User presses Enter to commit
/// 6. System sends TextInputEvent with final text "日本" and clears marked text
///
/// The `selected_range` indicates which portion of the marked text is currently
/// selected by the IME (for showing a selection highlight within the composition).
#[derive(Debug, Clone, PartialEq)]
pub struct MarkedTextEvent {
    /// The composed text being input
    pub text: String,
    /// Selected range within the marked text (for IME cursor).
    /// This is relative to the start of the marked text, not the document.
    pub selected_range: std::ops::Range<usize>,
    /// Range in buffer to replace (None = current marked text or cursor position).
    /// The range is in buffer character offsets from the start of the document.
    pub replacement_range: Option<std::ops::Range<usize>>,
}

impl MarkedTextEvent {
    /// Creates a new marked text event with the cursor at the end.
    pub fn new(text: impl Into<String>) -> Self {
        let text = text.into();
        let len = text.chars().count();
        Self {
            text,
            selected_range: len..len,
            replacement_range: None,
        }
    }

    /// Creates a new marked text event with a specified selection.
    pub fn with_selection(text: impl Into<String>, selected_range: std::ops::Range<usize>) -> Self {
        Self {
            text: text.into(),
            selected_range,
            replacement_range: None,
        }
    }
}

impl KeyEvent {
    /// Creates a new KeyEvent with the given key and modifiers.
    pub fn new(key: Key, modifiers: Modifiers) -> Self {
        Self { key, modifiers }
    }

    /// Creates a KeyEvent for a single character with no modifiers.
    pub fn char(ch: char) -> Self {
        Self {
            key: Key::Char(ch),
            modifiers: Modifiers::default(),
        }
    }

    /// Creates a KeyEvent for a single character with shift held.
    pub fn char_shifted(ch: char) -> Self {
        Self {
            key: Key::Char(ch),
            modifiers: Modifiers {
                shift: true,
                ..Default::default()
            },
        }
    }
}

/// Modifier keys that can be held during a key event.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
pub struct Modifiers {
    /// Shift key
    pub shift: bool,
    /// Command key (Cmd/⌘)
    pub command: bool,
    /// Option key (Alt/⌥)
    pub option: bool,
    /// Control key (Ctrl/⌃)
    pub control: bool,
}

impl Modifiers {
    /// Returns true if no modifier keys are held.
    pub fn is_empty(&self) -> bool {
        !self.shift && !self.command && !self.option && !self.control
    }

    /// Returns true if only shift is held (for uppercase letters).
    pub fn is_shift_only(&self) -> bool {
        self.shift && !self.command && !self.option && !self.control
    }
}

/// Keys that can be pressed.
#[derive(Debug, Clone, PartialEq)]
pub enum Key {
    /// A printable character (already accounts for shift state)
    Char(char),
    /// Backspace / Delete backward
    Backspace,
    /// Forward delete
    Delete,
    /// Return / Enter
    Return,
    /// Left arrow
    Left,
    /// Right arrow
    Right,
    /// Up arrow
    Up,
    /// Down arrow
    Down,
    /// Home key
    Home,
    /// End key
    End,
    /// Tab key
    Tab,
    /// Escape key
    Escape,
    /// Page Up
    PageUp,
    /// Page Down
    PageDown,
    // Chunk: docs/chunks/terminal_input_encoding - Terminal input encoding
    /// Insert key
    Insert,
    /// Function key F1
    F1,
    /// Function key F2
    F2,
    /// Function key F3
    F3,
    /// Function key F4
    F4,
    /// Function key F5
    F5,
    /// Function key F6
    F6,
    /// Function key F7
    F7,
    /// Function key F8
    F8,
    /// Function key F9
    F9,
    /// Function key F10
    F10,
    /// Function key F11
    F11,
    /// Function key F12
    F12,
}

// Chunk: docs/chunks/viewport_scrolling - Scroll event handling
// Chunk: docs/chunks/pane_hover_scroll - Mouse position for pane-targeted scrolling
/// Scroll delta from trackpad or mouse wheel.
///
/// In a multi-pane layout, the `mouse_position` field is used to determine
/// which pane should receive the scroll event. When `mouse_position` is `Some`,
/// the scroll routing logic uses hit-testing to target the pane under the cursor
/// rather than always routing to the focused pane.
#[derive(Debug, Clone, Copy, PartialEq)]
pub struct ScrollDelta {
    /// Horizontal scroll amount (positive = right)
    pub dx: f64,
    /// Vertical scroll amount (positive = down)
    pub dy: f64,
    /// Mouse position at the time of the scroll event, in view coordinates (pixels).
    ///
    /// This is `Some(x, y)` where the coordinates are in the same coordinate system
    /// as mouse events: origin at top-left, y increasing downward, in pixel units.
    /// Used for hover-scroll behavior in multi-pane layouts.
    pub mouse_position: Option<(f64, f64)>,
}

impl ScrollDelta {
    /// Creates a new ScrollDelta with no mouse position.
    ///
    /// Use this for programmatic scroll events or when mouse position is unavailable.
    pub fn new(dx: f64, dy: f64) -> Self {
        Self {
            dx,
            dy,
            mouse_position: None,
        }
    }

    /// Creates a new ScrollDelta with a mouse position.
    ///
    /// The position should be in view coordinates (pixels from top-left).
    /// This is used for hover-scroll behavior in multi-pane layouts.
    pub fn with_position(dx: f64, dy: f64, x: f64, y: f64) -> Self {
        Self {
            dx,
            dy,
            mouse_position: Some((x, y)),
        }
    }
}

/// A mouse event.
#[derive(Debug, Clone, PartialEq)]
pub struct MouseEvent {
    /// The type of mouse event
    pub kind: MouseEventKind,
    /// Position in view coordinates (pixels from top-left)
    pub position: (f64, f64),
    /// Modifier keys held during the event
    pub modifiers: Modifiers,
    // Chunk: docs/chunks/word_double_click_select - Double-click word selection
    /// Number of consecutive clicks (1 for single, 2 for double, etc.)
    pub click_count: u32,
}

/// Kind of mouse event.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum MouseEventKind {
    /// Mouse button pressed
    Down,
    /// Mouse button released
    Up,
    /// Mouse moved (with button held for drag)
    Moved,
}

// Chunk: docs/chunks/pty_wakeup_reentrant - WakeupSignal trait for cross-crate PTY wakeup
/// Trait for signaling the main thread's event loop from background threads.
///
/// This trait allows the terminal crate to signal the editor's event loop
/// when PTY data arrives, without depending on the editor crate directly.
/// The editor provides an implementation that sends `EditorEvent::PtyWakeup`
/// to the event channel.
///
/// # Thread Safety
///
/// Implementations must be `Send + Sync` so that they can be used from the
/// PTY reader thread. The `signal()` method should be cheap and non-blocking.
///
/// # Example
///
/// ```ignore
/// // In the editor crate:
/// struct EventSenderSignal(mpsc::Sender<EditorEvent>);
///
/// impl WakeupSignal for EventSenderSignal {
///     fn signal(&self) {
///         let _ = self.0.send(EditorEvent::PtyWakeup);
///         // Wake the run loop...
///     }
/// }
///
/// // In the terminal crate:
/// fn spawn_shell(wakeup: impl WakeupSignal) {
///     // ... reader thread calls wakeup.signal() when data arrives
/// }
/// ```
pub trait WakeupSignal: Send + Sync {
    /// Signal that PTY data is available.
    ///
    /// This method should be cheap and non-blocking. It's called from the
    /// PTY reader thread whenever data arrives. The implementation should
    /// wake the main thread's event loop to process the data.
    fn signal(&self);
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_key_event_char() {
        let event = KeyEvent::char('a');
        assert_eq!(event.key, Key::Char('a'));
        assert!(event.modifiers.is_empty());
    }

    #[test]
    fn test_key_event_char_shifted() {
        let event = KeyEvent::char_shifted('A');
        assert_eq!(event.key, Key::Char('A'));
        assert!(event.modifiers.is_shift_only());
    }

    #[test]
    fn test_modifiers_is_empty() {
        let empty = Modifiers::default();
        assert!(empty.is_empty());

        let with_shift = Modifiers {
            shift: true,
            ..Default::default()
        };
        assert!(!with_shift.is_empty());
    }

    #[test]
    fn test_modifiers_is_shift_only() {
        let shift_only = Modifiers {
            shift: true,
            ..Default::default()
        };
        assert!(shift_only.is_shift_only());

        let shift_and_cmd = Modifiers {
            shift: true,
            command: true,
            ..Default::default()
        };
        assert!(!shift_and_cmd.is_shift_only());
    }

    // Chunk: docs/chunks/unicode_ime_input - Tests for text input events

    #[test]
    fn test_text_input_event_new() {
        let event = TextInputEvent::new("hello");
        assert_eq!(event.text, "hello");
        assert!(event.replacement_range.is_none());
    }

    #[test]
    fn test_text_input_event_with_replacement() {
        let event = TextInputEvent::with_replacement("日本", 0..4);
        assert_eq!(event.text, "日本");
        assert_eq!(event.replacement_range, Some(0..4));
    }

    #[test]
    fn test_text_input_event_unicode() {
        let event = TextInputEvent::new("日本語");
        assert_eq!(event.text, "日本語");
        assert_eq!(event.text.chars().count(), 3);
    }

    #[test]
    fn test_marked_text_event_new() {
        let event = MarkedTextEvent::new("にほん");
        assert_eq!(event.text, "にほん");
        // selected_range should be at the end (3 chars)
        assert_eq!(event.selected_range, 3..3);
        assert!(event.replacement_range.is_none());
    }

    #[test]
    fn test_marked_text_event_with_selection() {
        let event = MarkedTextEvent::with_selection("nihon", 2..5);
        assert_eq!(event.text, "nihon");
        assert_eq!(event.selected_range, 2..5);
        assert!(event.replacement_range.is_none());
    }

    #[test]
    fn test_marked_text_event_empty() {
        let event = MarkedTextEvent::new("");
        assert_eq!(event.text, "");
        assert_eq!(event.selected_range, 0..0);
    }

    #[test]
    fn test_text_input_event_equality() {
        let event1 = TextInputEvent::new("hello");
        let event2 = TextInputEvent::new("hello");
        let event3 = TextInputEvent::new("world");

        assert_eq!(event1, event2);
        assert_ne!(event1, event3);
    }

    #[test]
    fn test_marked_text_event_equality() {
        let event1 = MarkedTextEvent::new("test");
        let event2 = MarkedTextEvent::new("test");
        let event3 = MarkedTextEvent::with_selection("test", 0..2);

        assert_eq!(event1, event2);
        assert_ne!(event1, event3); // Different selected_range
    }
}
